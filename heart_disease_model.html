<html lang="en"><head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html-to-image/1.11.13/html-to-image.min.js" integrity="sha512-iZ2ORl595Wx6miw+GuadDet4WQbdSWS3JLMoNfY8cRGoEFy6oT3G9IbcrBeL6AfkgpA51ETt/faX6yLV+/gFJg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script>
      (function() {
        const originalConsole = window.console;
        window.console = {
          log: (...args) => {
            originalConsole.log(...args);
            window.parent.postMessage({ type: 'console', message: args.join(' ') }, '*');
          },
          error: (...args) => {
            originalConsole.error(...args);
            window.parent.postMessage({ type: 'console', message: 'Error: ' + args.join(' ') }, '*');
          },
          warn: (...args) => {
            originalConsole.warn(...args);
            window.parent.postMessage({ type: 'console', message: 'Warning: ' + args.join(' ') }, '*');
          }
        };

        let requestId = 0;
        let callbacksMap = new Map();
        let streamControllers = new Map();
        
        window.claude = {
          complete: (prompt) => {
            return new Promise((resolve, reject) => {
              const id = requestId++;
              callbacksMap.set(id, { resolve, reject });
              window.parent.postMessage({ type: 'claudeComplete', id, prompt }, '*');
            });
          }
        };

        window.storage = {
          get: (key, shared = false) => {
            return new Promise((resolve, reject) => {
              const id = requestId++;
              callbacksMap.set(id, { resolve, reject });
              window.parent.postMessage({ type: 'storageGet', id, key, shared }, '*');
            });
          },
          set: (key, value, shared = false) => {
            return new Promise((resolve, reject) => {
              const id = requestId++;
              callbacksMap.set(id, { resolve, reject });
              window.parent.postMessage({ type: 'storageSet', id, key, value, shared }, '*');
            });
          },
          delete: (key, shared = false) => {
            return new Promise((resolve, reject) => {
              const id = requestId++;
              callbacksMap.set(id, { resolve, reject });
              window.parent.postMessage({ type: 'storageDelete', id, key, shared }, '*');
            });
          },
          list: (prefix, shared = false) => {
            return new Promise((resolve, reject) => {
              const id = requestId++;
              callbacksMap.set(id, { resolve, reject });
              window.parent.postMessage({ type: 'storageList', id, prefix, shared }, '*');
            });
          }
        };

        let pendingBlobs = new Map();
        URL.createObjectURL = (blob) => {
          // Store the blob and create an ID and URL for it
          const blobId = `blob-${Date.now()}-${Math.random()}`;
          pendingBlobs.set(blobId, blob);
          return `blob-request://${blobId}`;
        };

        URL.revokeObjectURL = (url) => {
          // Remove the blob from our store
          const blobId = url.replace("blob-request://", "");
          pendingBlobs.delete(blobId);
        };

        const getBlobFromURL = (url) => {
          const blobId = url.replace("blob-request://", "");
          return pendingBlobs.get(blobId);
        };

        // Override global fetch with streaming support
        window.fetch = (url, init = {}) => {
          return new Promise((resolve, reject) => {
            const id = requestId++;
            const channelId = `fetch-${id}-${Date.now()}`;
            
            callbacksMap.set(id, { 
              resolve: (response) => {
                // Create a ReadableStream for the response body
                const stream = new ReadableStream({
                  start(controller) {
                    streamControllers.set(channelId, controller);
                  },
                  cancel() {
                    streamControllers.delete(channelId);
                  }
                });
                
                // Create and return the Response with the stream
                resolve(new Response(stream, {
                  status: response.status,
                  statusText: response.statusText,
                  headers: response.headers
                }));
              },
              reject,
              channelId
            });
            
            window.parent.postMessage({
              type: 'proxyFetch',
              id,
              url,
              init,
              channelId
            }, '*');
          });
        };

        window.addEventListener('message', async (event) => {
          if (event.data.type === 'takeScreenshot') {
            const rootElement = document.getElementById('artifacts-component-root-html');
            if (!rootElement) {
              window.parent.postMessage({
                type: 'screenshotError',
                error: new Error('Root element not found'),
              }, '*');
            }
            const screenshot = await htmlToImage.toPng(rootElement, {
              imagePlaceholder:
                "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAA1JREFUGFdjePDgwX8ACOQDoNsk0PMAAAAASUVORK5CYII=",
            });
            window.parent.postMessage({
              type: 'screenshotData',
              data: screenshot,
            }, '*');
          } else if (event.data.type === 'claudeComplete') {
            const callback = callbacksMap.get(event.data.id);
            if (event.data.error) {
              callback.reject(new Error(event.data.error));
            } else {
              callback.resolve(event.data.completion);
            }
            callbacksMap.delete(event.data.id);
          } else if (event.data.type === 'proxyFetchResponse') {
            const callback = callbacksMap.get(event.data.id);
            if (event.data.error) {
              callback.reject(new Error(event.data.error));
              callbacksMap.delete(event.data.id);
            } else {
              // Initial response with headers, status, etc.
              callback.resolve({
                status: event.data.status,
                statusText: event.data.statusText,
                headers: event.data.headers
              });
              // Don't delete the callback yet if streaming
              if (!event.data.body) {
                callbacksMap.delete(event.data.id);
              }
            }
          } else if (event.data.type === 'proxyFetchStream') {
            // Handle streaming data chunks
            const controller = streamControllers.get(event.data.channelId);
            if (controller) {
              if (event.data.error) {
                controller.error(new Error(event.data.error));
                streamControllers.delete(event.data.channelId);
              } else if (event.data.done) {
                controller.close();
                streamControllers.delete(event.data.channelId);
                // Clean up the callback
                const callback = Array.from(callbacksMap.entries()).find(
                  ([_, value]) => value.channelId === event.data.channelId
                );
                if (callback) {
                  callbacksMap.delete(callback[0]);
                }
              } else if (event.data.chunk) {
                controller.enqueue(new Uint8Array(event.data.chunk));
              }
            }
          } else if (event.data.type === 'storageGet') {
            const callback = callbacksMap.get(event.data.id);
            if (event.data.error) {
              callback.reject(new Error(event.data.error));
            } else {
              callback.resolve(event.data.result);
            }
            callbacksMap.delete(event.data.id);
          } else if (event.data.type === 'storageSet') {
            const callback = callbacksMap.get(event.data.id);
            if (event.data.error) {
              callback.reject(new Error(event.data.error));
            } else {
              callback.resolve(event.data.result);
            }
            callbacksMap.delete(event.data.id);
          } else if (event.data.type === 'storageDelete') {
            const callback = callbacksMap.get(event.data.id);
            if (event.data.error) {
              callback.reject(new Error(event.data.error));
            } else {
              callback.resolve(event.data.result);
            }
            callbacksMap.delete(event.data.id);
          } else if (event.data.type === 'storageList') {
            const callback = callbacksMap.get(event.data.id);
            if (event.data.error) {
              callback.reject(new Error(event.data.error));
            } else {
              callback.resolve(event.data.result);
            }
            callbacksMap.delete(event.data.id);
          }
        });

        window.addEventListener('click', (event) => {
          const isEl = event.target instanceof HTMLElement;
          if (!isEl) return;
    
          // find ancestor links
          const linkEl = event.target.closest("a");
          if (!linkEl || !linkEl.href) return;
    
          event.preventDefault();
          event.stopImmediatePropagation();
    
          if (linkEl.href.startsWith("blob-request:")) {
            const blob = getBlobFromURL(linkEl.href);
            if (!blob) return;
            void blob.arrayBuffer().then((data) => {
              window.parent.postMessage({
                type: "downloadFile",
                filename: linkEl.download,
                data,
                mimeType: blob.type || "application/octet-stream",
              });
            });
          } else if (linkEl.href.startsWith("data:")) {
            const [header, base64Data] = linkEl.href.split(",");
            const mimeMatch = header.match(/data:([^;]+)/);
            const mimeType = mimeMatch ? mimeMatch[1] : "application/octet-stream";
            const binaryString = atob(base64Data);
            const data = Uint8Array.from(binaryString, (c) =>
              c.charCodeAt(0),
            ).buffer;
            window.parent.postMessage({
              type: "downloadFile",
              filename: linkEl.download,
              data,
              mimeType,
            });
          } else {
            let linkUrl;
            try {
              linkUrl = new URL(linkEl.href);
            } catch (error) {
              return;
            }
    
            if (linkUrl.hostname === window.location.hostname) return;
      
            window.parent.postMessage({
              type: 'openExternal',
              href: linkEl.href,
            }, '*');
          }
      });

        const originalOpen = window.open;
        window.open = function (url) {
          window.parent.postMessage({
            type: "openExternal",
            href: url,
          }, "*");
        };

        window.addEventListener('error', (event) => {
          window.parent.postMessage({ type: 'console', message: 'Uncaught Error: ' + event.message }, '*');
        });
      })();
    </script>
  
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Heart Disease Prediction Model</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
            background-color: #fff;
            color: #212529;
            line-height: 1.6;
            padding: 20px;
        }

        .notebook {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
        }

        .cell {
            margin-bottom: 0;
            border-left: 3px solid transparent;
        }

        .cell:hover {
            border-left-color: #2196F3;
        }

        .cell-header {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            font-size: 13px;
            color: #666;
            font-family: 'Consolas', 'Monaco', monospace;
        }

        .cell-label {
            min-width: 80px;
            font-weight: 600;
        }

        .markdown-cell {
            padding: 20px 12px;
        }

        .markdown-cell h1 {
            font-size: 32px;
            font-weight: 400;
            margin-bottom: 20px;
            color: #212529;
        }

        .markdown-cell h2 {
            font-size: 24px;
            font-weight: 400;
            margin: 30px 0 15px 0;
            color: #212529;
        }

        .markdown-cell h3 {
            font-size: 20px;
            font-weight: 600;
            margin: 25px 0 15px 0;
            color: #212529;
        }

        .markdown-cell p {
            margin-bottom: 15px;
            color: #212529;
        }

        .markdown-cell ul {
            margin: 10px 0 15px 20px;
        }

        .markdown-cell li {
            margin: 8px 0;
        }

        .markdown-cell strong {
            font-weight: 600;
        }

        .markdown-cell code {
            background: #f5f5f5;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 13px;
            color: #c7254e;
        }

        .code-cell {
            background: #f7f7f7;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            margin: 8px 12px;
            overflow: hidden;
        }

        .code-input {
            background: #f7f7f7;
            padding: 12px 16px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 13px;
            line-height: 1.5;
            color: #212529;
            overflow-x: auto;
        }

        .code-output {
            background: white;
            border-top: 1px solid #e0e0e0;
            padding: 12px 16px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 13px;
            overflow-x: auto;
        }

        .keyword {
            color: #008000;
            font-weight: bold;
        }

        .string {
            color: #BA2121;
        }

        .comment {
            color: #408080;
            font-style: italic;
        }

        table {
            border-collapse: collapse;
            width: 100%;
            margin: 15px 0;
            font-size: 13px;
        }

        th, td {
            border: 1px solid #ddd;
            padding: 8px 12px;
            text-align: left;
        }

        th {
            background-color: #f5f5f5;
            font-weight: 600;
        }

        tr:hover {
            background-color: #f9f9f9;
        }

        .output-text {
            white-space: pre-wrap;
            color: #212529;
        }
    </style>
</head>
<body id="artifacts-component-root-html">
    <div class="notebook">
        <!-- Download Button -->
        <div style="position: fixed; top: 20px; right: 20px; z-index: 1000;">
            <button onclick="downloadHTML()" style="background: #2196F3; color: white; border: none; padding: 12px 24px; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: 600; box-shadow: 0 2px 5px rgba(0,0,0,0.2);">
                ⬇️ Download HTML
            </button>
        </div>

        <!-- Title Cell -->
        <div class="cell markdown-cell">
            <h1>Heart Disease Prediction Model</h1>
            <h2>Cardiovascular Risk Classification using Random Forest</h2>
        </div>

        <!-- Import Libraries -->
        <div class="cell markdown-cell">
            <h3>Import Libraries</h3>
        </div>

        <div class="cell">
            <div class="cell-header">
                <span class="cell-label">In [ ]:</span>
            </div>
            <div class="code-cell">
                <div class="code-input"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd
<span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> Pipeline
<span class="keyword">from</span> sklearn.compose <span class="keyword">import</span> ColumnTransformer
<span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> OneHotEncoder, StandardScaler
<span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier
<span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split
<span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> classification_report, accuracy_score
<span class="keyword">import</span> joblib</div>
            </div>
        </div>

        <!-- Dataset Overview -->
        <div class="cell markdown-cell">
            <h2>Dataset Overview</h2>
            <p>The dataset contains anonymized health information for patients, including features such as age, sex, cholesterol levels, and presence of heart disease. It is used to train a binary classification model to predict cardiovascular risk.</p>
            
            <p><strong>Feature Descriptions:</strong></p>
            <ul>
                <li><code>age</code> : Age of the patient</li>
                <li><code>sex</code> : Gender</li>
                <li><code>ChestPainType</code> : Chest pain type</li>
                <li><code>RestingBP</code> : Resting blood pressure</li>
                <li><code>Cholesterol</code> : Serum cholesterol in mg/dl</li>
                <li><code>FastingBS</code> : Fasting blood sugar</li>
                <li><code>RestingECG</code> : resting electrocardiogram results</li>
                <li><code>MaxHR</code> : Maximum heart rate achieved</li>
                <li><code>ExerciseAngina</code> : Exercise induced angina</li>
                <li><code>oldpeak</code> : ST depression induced by exercise relative to rest</li>
                <li><code>ST_Slope</code> : the slope of the peak exercise ST segment</li>
                <li><code>target</code> : 1 = risk, 0 = no risk</li>
            </ul>
        </div>

        <!-- Data Loading -->
        <div class="cell markdown-cell">
            <h3>Data Loading</h3>
        </div>

        <div class="cell">
            <div class="cell-header">
                <span class="cell-label">In [ ]:</span>
            </div>
            <div class="code-cell">
                <div class="code-input">df = pd.read_csv(<span class="string">'/content/heart.csv'</span>)
df.head()</div>
            </div>
        </div>

        <div class="cell">
            <div class="cell-header">
                <span class="cell-label">Out[ ]:</span>
            </div>
            <div class="code-cell">
                <div class="code-output">
                    <table>
                        <thead>
                            <tr>
                                <th></th>
                                <th>Age</th>
                                <th>Sex</th>
                                <th>ChestPainType</th>
                                <th>RestingBP</th>
                                <th>Cholesterol</th>
                                <th>FastingBS</th>
                                <th>RestingECG</th>
                                <th>MaxHR</th>
                                <th>ExerciseAngina</th>
                                <th>Oldpeak</th>
                                <th>ST_Slope</th>
                                <th>HeartDisease</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <th>0</th>
                                <td>40</td>
                                <td>M</td>
                                <td>ATA</td>
                                <td>140</td>
                                <td>289</td>
                                <td>0</td>
                                <td>Normal</td>
                                <td>172</td>
                                <td>N</td>
                                <td>0.0</td>
                                <td>Up</td>
                                <td>0</td>
                            </tr>
                            <tr>
                                <th>1</th>
                                <td>49</td>
                                <td>F</td>
                                <td>NAP</td>
                                <td>160</td>
                                <td>180</td>
                                <td>0</td>
                                <td>Normal</td>
                                <td>156</td>
                                <td>N</td>
                                <td>1.0</td>
                                <td>Flat</td>
                                <td>1</td>
                            </tr>
                            <tr>
                                <th>2</th>
                                <td>37</td>
                                <td>M</td>
                                <td>ATA</td>
                                <td>130</td>
                                <td>283</td>
                                <td>0</td>
                                <td>ST</td>
                                <td>98</td>
                                <td>N</td>
                                <td>0.0</td>
                                <td>Up</td>
                                <td>0</td>
                            </tr>
                            <tr>
                                <th>3</th>
                                <td>48</td>
                                <td>F</td>
                                <td>ASY</td>
                                <td>138</td>
                                <td>214</td>
                                <td>0</td>
                                <td>Normal</td>
                                <td>108</td>
                                <td>Y</td>
                                <td>1.5</td>
                                <td>Flat</td>
                                <td>1</td>
                            </tr>
                            <tr>
                                <th>4</th>
                                <td>54</td>
                                <td>M</td>
                                <td>NAP</td>
                                <td>150</td>
                                <td>195</td>
                                <td>0</td>
                                <td>Normal</td>
                                <td>122</td>
                                <td>N</td>
                                <td>0.0</td>
                                <td>Up</td>
                                <td>0</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Info Cell -->
        <div class="cell">
            <div class="cell-header">
                <span class="cell-label">In [ ]:</span>
            </div>
            <div class="code-cell">
                <div class="code-input">print(df.info())</div>
                <div class="code-output">
                    <div class="output-text">&lt;class 'pandas.core.frame.DataFrame'&gt;
RangeIndex: 918 entries, 0 to 917
Data columns (total 12 columns):
 #   Column          Non-Null Count  Dtype  
---  ------          --------------  -----  
 0   Age             918 non-null    int64  
 1   Sex             918 non-null    object 
 2   ChestPainType   918 non-null    object 
 3   RestingBP       918 non-null    int64  
 4   Cholesterol     918 non-null    int64  
 5   FastingBS       918 non-null    int64  
 6   RestingECG      918 non-null    object 
 7   MaxHR           918 non-null    int64  
 8   ExerciseAngina  918 non-null    object 
 9   Oldpeak         918 non-null    float64
 10  ST_Slope        918 non-null    object 
 11  HeartDisease    918 non-null    int64  
dtypes: float64(1), int64(6), object(5)
memory usage: 86.2+ KB
None</div>
                </div>
            </div>
        </div>

        <!-- Missing Values -->
        <div class="cell">
            <div class="cell-header">
                <span class="cell-label">In [ ]:</span>
            </div>
            <div class="code-cell">
                <div class="code-input">df.isnull().sum()</div>
                <div class="code-output">
                    <div class="output-text">Age               0
Sex               0
ChestPainType     0
RestingBP         0
Cholesterol       0
FastingBS         0
RestingECG        0
MaxHR             0
ExerciseAngina    0
Oldpeak           0
ST_Slope          0
HeartDisease      0
dtype: int64</div>
                </div>
            </div>
        </div>

        <!-- Data Preprocessing -->
        <div class="cell markdown-cell">
            <h3>Data Preprocessing</h3>
        </div>

        <div class="cell">
            <div class="cell-header">
                <span class="cell-label">In [ ]:</span>
            </div>
            <div class="code-cell">
                <div class="code-input"><span class="comment"># Separate features and target</span>
X = df.drop(<span class="string">'HeartDisease'</span>, axis=<span class="string">1</span>)
y = df[<span class="string">'HeartDisease'</span>]</div>
            </div>
        </div>

        <div class="cell">
            <div class="cell-header">
                <span class="cell-label">In [ ]:</span>
            </div>
            <div class="code-cell">
                <div class="code-input">categorical_cols = [<span class="string">"Sex"</span>, <span class="string">"ChestPainType"</span>, <span class="string">"RestingECG"</span>, <span class="string">"ExerciseAngina"</span>, <span class="string">"ST_Slope"</span>]
numerical_cols = [<span class="string">"Age"</span>, <span class="string">"RestingBP"</span>, <span class="string">"Cholesterol"</span>, <span class="string">"FastingBS"</span>, <span class="string">"MaxHR"</span>, <span class="string">"Oldpeak"</span>]</div>
            </div>
        </div>

        <div class="cell">
            <div class="cell-header">
                <span class="cell-label">In [ ]:</span>
            </div>
            <div class="code-cell">
                <div class="code-input">categorical_transformer = OneHotEncoder(handle_unknown=<span class="string">'ignore'</span>)
numerical_transformer = StandardScaler()</div>
            </div>
        </div>

        <div class="cell">
            <div class="cell-header">
                <span class="cell-label">In [ ]:</span>
            </div>
            <div class="code-cell">
                <div class="code-input">preprocessor = ColumnTransformer(
    transformers=[
        (<span class="string">'num'</span>, numerical_transformer, numerical_cols),
        (<span class="string">'cat'</span>, categorical_transformer, categorical_cols)
    ]
)</div>
            </div>
        </div>

        <div class="cell">
            <div class="cell-header">
                <span class="cell-label">In [ ]:</span>
            </div>
            <div class="code-cell">
                <div class="code-input">pipeline = Pipeline(steps=[
    (<span class="string">'preprocessor'</span>, preprocessor),
    (<span class="string">'classifier'</span>, RandomForestClassifier(random_state=<span class="string">42</span>))
])</div>
            </div>
        </div>

        <!-- Model Training -->
        <div class="cell">
            <div class="cell-header">
                <span class="cell-label">In [ ]:</span>
            </div>
            <div class="code-cell">
                <div class="code-input">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="string">0.2</span>, random_state=<span class="string">42</span>)

pipeline.fit(X_train, y_train)

print(<span class="string">f"Model accuracy: {pipeline.score(X_test, y_test):.2f}"</span>)</div>
                <div class="code-output">
                    <div class="output-text">Model accuracy: 0.88</div>
                </div>
            </div>
        </div>

        <!-- Classification Report -->
        <div class="cell">
            <div class="cell-header">
                <span class="cell-label">In [ ]:</span>
            </div>
            <div class="code-cell">
                <div class="code-input"><span class="comment"># f1 score and other metrics</span>
y_pred = pipeline.predict(X_test)
print(classification_report(y_test, y_pred))</div>
                <div class="code-output">
                    <div class="output-text">              precision    recall  f1-score   support

           0       0.85      0.87      0.86        77
           1       0.90      0.89      0.90       107

    accuracy                           0.88       184
   macro avg       0.88      0.88      0.88       184
weighted avg       0.88      0.88      0.88       184</div>
                </div>
            </div>
        </div>

        <!-- Save Model -->
        <div class="cell">
            <div class="cell-header">
                <span class="cell-label">In [ ]:</span>
            </div>
            <div class="code-cell">
                <div class="code-input"><span class="comment">#Saving the Model</span>
joblib.dump(pipeline, <span class="string">"cr_model.pkl"</span>)</div>
                <div class="code-output">
                    <div class="output-text">['cr_model.pkl']</div>
                </div>
            </div>
        </div>

        <!-- Conclusion -->
        <div class="cell markdown-cell">
            <h2>Conclusion</h2>
            <p>The trained Random Forest model achieved good accuracy and F1-score. The model is saved for integration into the Streamlit-based CardioRural application.</p>
            
            <h2>Next Steps</h2>
            <ul>
                <li>Validate the model with external data</li>
                <li>Tune hyperparameters for better performance</li>
                <li>Deploy on low-resource mobile platforms</li>
            </ul>
        </div>
    </div>

    <script>
        function downloadHTML() {
            const htmlContent = document.documentElement.outerHTML;
            const blob = new Blob([htmlContent], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'heart_disease_model.html';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
    </script>

</body></html>